<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>calabash519</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-15T15:52:45.448Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>calabash519</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6学习总结（五）</title>
    <link href="http://yoursite.com/2017/08/15/obj-property-copy/"/>
    <id>http://yoursite.com/2017/08/15/obj-property-copy/</id>
    <published>2017-08-15T11:04:43.000Z</published>
    <updated>2017-08-15T15:52:45.448Z</updated>
    
    <content type="html"><![CDATA[<p>与其说是对象合并，还不如说是JavaScript中对象属性的复制和转移，将多个对象中的属性合并到一个对象中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">'John'</span>,</div><div class="line">	<span class="attr">age</span>  : <span class="number">24</span></div><div class="line">&#125;,</div><div class="line">location = &#123;</div><div class="line">	<span class="attr">address</span> : <span class="string">'Location'</span>,</div><div class="line">	<span class="attr">city</span> : <span class="string">'NewYork'</span></div><div class="line">&#125; ;</div></pre></td></tr></table></figure>
<a id="more"></a>如何可以做到将上述两个对象中的属性合并到同一个对象中，介绍ES6的一个新的方法，Object.assign，如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.assign(target, ...sources) // target为目标对象，sources可以是多个源对象</div></pre></td></tr></table></figure>
<p>这个方法可以帮助我们拷贝多个源对象中所有可以被枚举的自身属性到目标对象中，如果目标对象中的属性与源对象中的属性相同的话，源对象的属性会覆盖目标对象的属性，需要注意的是，这里面可以拷贝的属性必须是可以被枚举的自身属性，一个是可枚举，一个是自身，两个条件是必须的，这个方法作用的过程中，会先调用源对象的getter方法，然后调用目标对象的setter方法，从而达到拷贝属性到目标对象的目的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(person,location); </div><div class="line"><span class="comment">/* 现在我们应该可以看到，person对象中会有四个属性 </span></div><div class="line">name , age , address, city */</div></pre></td></tr></table></figure>
<p>在ES6里面我们使用Obj.assign，我们也可以用ES5来模拟Obj.assign，需要注意拷贝自身的可枚举属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assign</span>(<span class="params">target, source</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> source === <span class="string">'object'</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</div><div class="line">      <span class="keyword">if</span> (fromObj.hasOwnProperty(key)) &#123;</div><div class="line">        target[key] = source[key];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">  	<span class="keyword">throw</span> <span class="string">"Assign function can apply only on object"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与其说是对象合并，还不如说是JavaScript中对象属性的复制和转移，将多个对象中的属性合并到一个对象中&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;John&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;  : &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;location = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;address&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;Location&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;city&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;NewYork&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6学习总结（四）</title>
    <link href="http://yoursite.com/2017/08/13/ES6-points-module/"/>
    <id>http://yoursite.com/2017/08/13/ES6-points-module/</id>
    <published>2017-08-13T07:30:35.000Z</published>
    <updated>2017-08-13T14:04:00.845Z</updated>
    
    <content type="html"><![CDATA[<p> ES6模块化之前，前端模块化之路可谓是布满沧桑，从最开始的刀耕火种，无数的脚本层叠在一起引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"a.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"b.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"c.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"d.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>到匿名函数自执行封装代码<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(window)&#123;</div><div class="line">    // your code here</div><div class="line"> &#125;)();</div></pre></td></tr></table></figure>
<p>再到后来的common.js，以及后面的require.js和AMD</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'a'</span>).add;</div><div class="line">exports.increment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"><span class="comment">// c.js</span></div><div class="line"><span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">'b'</span>).increment;</div></pre></td></tr></table></figure>
<p>可以看出前端模块化一直在进步，但是始终没有一致的标准，直到ES6实现模块化之后，前端的模块化之路才慢慢的变得比较统一，ES6使用import和export来实现模块化，默认情况下，模块皆是在严格模式下运行，可以导出外层函数，类与对象或者所有定义的变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"hello world"</span> </div><div class="line">&#125;</div><div class="line"><span class="comment">// b.js </span></div><div class="line"><span class="keyword">import</span> &#123;hello&#125; <span class="keyword">from</span> <span class="string">"a.js"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	hello();  </div><div class="line">&#125;</div><div class="line">sayHello();</div></pre></td></tr></table></figure>
<p>ES6模块化中import和export也可以重命名，若是有时候导出的名字跟其他的正在使用中的名字有冲突的时候，在导入的时候可以使用as来重命名（突然间想起来SQL）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;hello <span class="keyword">as</span> cala&#125; <span class="keyword">from</span> <span class="string">"a.js"</span>;</div></pre></td></tr></table></figure>
<p>可以用两个不一样的名字来导出相同的值，ES6中可以使用default关键字来实现默认导出，不能在语句和函数之内使用export关键字，只能在模块顶部使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"hello world"</span> </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  hello <span class="keyword">as</span> foo,</div><div class="line">  hello <span class="keyword">as</span> bar</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//default</span></div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">  <span class="attr">key1</span>:value1,</div><div class="line">  <span class="attr">key2</span>:value2</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> &#123;obj <span class="keyword">as</span> <span class="keyword">default</span>&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">  <span class="attr">key1</span>:value1,</div><div class="line">  <span class="attr">key2</span>:value2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6模块化负责处理不同模块间的耦合关联，具体到编译时处理所有的模块依赖，将模块打包成文件传输等工作可以用打包工具webpack等来完成，目前来说，ES6模块化的标准仍然在路上，不过也已经普及，以后希望能继续发展，让前端更好的发展。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; ES6模块化之前，前端模块化之路可谓是布满沧桑，从最开始的刀耕火种，无数的脚本层叠在一起引入&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&quot;a.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&quot;b.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&quot;c.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&quot;d.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ECMAscript6" scheme="http://yoursite.com/categories/ECMAscript6/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6学习总结（三）</title>
    <link href="http://yoursite.com/2017/08/12/ES6-points-class/"/>
    <id>http://yoursite.com/2017/08/12/ES6-points-class/</id>
    <published>2017-08-11T18:28:08.000Z</published>
    <updated>2017-08-13T14:02:53.311Z</updated>
    
    <content type="html"><![CDATA[<p> 不同于其他面向对象语言，ES6以前的JavaScript中中没有类的概念，主要是通过原型的方式来实现继承，JavaScript中引入了原型链，并且将原型链用来实现继承，其核心是利用原型使得一个对象继承另一个对象的方法和属性，JavaScript中原型继承的关键是将一个实例的原型对象指向另一个实例，因此前一个实例便可以获得后一个实例原型对象的属性和方法<a id="more"></a>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.age=<span class="number">30</span>;</div><div class="line">&#125;</div><div class="line">Father.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hard work"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.age=<span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将child的原型指向Father构造函数的实例</span></div><div class="line">Child.prototype=<span class="keyword">new</span> Father();</div><div class="line"></div><div class="line">Child.prototype.play=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"play"</span>;				</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child.play()) <span class="comment">// play</span></div><div class="line"><span class="built_in">console</span>.log(child.work()) <span class="comment">// work</span></div></pre></td></tr></table></figure>
<p>看完了上面的JavaScript典型的原型继承，要回到ES6上面了，ES6中引入了类的概念，class实际上是语法糖，很多都与构造函数,原型对象相关，先看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var Man = class&#123;&#125; </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age) &#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">  &#125;</div><div class="line">  grow()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age+<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Man(<span class="number">22</span>);</div><div class="line"><span class="built_in">console</span>.log(cala.grow()); <span class="comment">// 23</span></div></pre></td></tr></table></figure>
<p>上面是一个简单的ES6写class的例子，可以看到的是，用class关键字定义类，里面的constructor指的是构造函数，在构造函数中定义私有属性，然后接着定义了一个grow方法，最后通过new关键字来实例化一个对象</p>
<p>在JavaScript中定义类和定义函数很相似，不过两者还是有些不同，函数声明可以提升，但是类声明则不行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Man();</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;&#125; <span class="comment">// Man is not defined</span></div></pre></td></tr></table></figure>
<p>ES6中的类使用 extends创建子类，每个类里面都会有一个constructor构造函数，实例化的时候必须用new关键字来调用类的构造函数，一个构造函数可以通过super来调用另一个构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age) &#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> work()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"hard work"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cala</span> <span class="keyword">extends</span> <span class="title">Man</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age)&#123;</div><div class="line">    <span class="keyword">super</span>(age);</div><div class="line">  &#125;</div><div class="line">  grow()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age+<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Cala(<span class="number">22</span>);</div><div class="line"><span class="built_in">console</span>.log(cala.grow()) <span class="comment">// 23</span></div></pre></td></tr></table></figure>
<p>ES6中的class支持类支持在原型上定义访问器get，set属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age) &#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">  &#125;</div><div class="line">  get getAge()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">  &#125;</div><div class="line">  set setAge(age)&#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Man(<span class="number">22</span>);</div><div class="line"><span class="built_in">console</span>.log(cala.getAge) <span class="comment">// 22</span></div><div class="line"></div><div class="line">cala.setAge=<span class="number">33</span>;</div><div class="line"><span class="built_in">console</span>.log(cala.getAge) <span class="comment">// 33</span></div></pre></td></tr></table></figure>
<p>ES6的class中支持静态方法，用关键字static来定义，熟悉面向类与对象的童鞋大多知道，静态方法属于类本身，是通过类来调用，不能通过实例来调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age) &#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> work()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"hard work"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Man.work()); <span class="comment">// hard work</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Man(<span class="number">22</span>);</div><div class="line"><span class="built_in">console</span>.log(cala.work()); <span class="comment">// cala.work is not a function</span></div></pre></td></tr></table></figure>
<p>结合上面JavaScript典型的原型继承和下面的ES6的类，可以看出在使用new关键字实例化对象的时候，实际上是调用了prototype上的构造函数，ES6的class本质就是语法糖，对于传统的写法来说，也是可以在ES6中适用的，类上的方法其实也就相当于定义在prototype上面</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 不同于其他面向对象语言，ES6以前的JavaScript中中没有类的概念，主要是通过原型的方式来实现继承，JavaScript中引入了原型链，并且将原型链用来实现继承，其核心是利用原型使得一个对象继承另一个对象的方法和属性，JavaScript中原型继承的关键是将一个实例的原型对象指向另一个实例，因此前一个实例便可以获得后一个实例原型对象的属性和方法
    
    </summary>
    
      <category term="ECMAscript6" scheme="http://yoursite.com/categories/ECMAscript6/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6学习总结（二）</title>
    <link href="http://yoursite.com/2017/08/11/ES6-points-function/"/>
    <id>http://yoursite.com/2017/08/11/ES6-points-function/</id>
    <published>2017-08-10T16:38:06.000Z</published>
    <updated>2017-08-13T13:58:52.047Z</updated>
    
    <content type="html"><![CDATA[<p>关于ES6的学习总结，前两天写了第一篇，主要是关于变量声明关键字let和const，新增类型Symbol以及模板字符串，今天准备写第二篇，ES6里面的函数部分，ES6新增了箭头函数，Rest参数以及参数默认值。<a id="more"></a></p>
<p><strong>箭头函数</strong></p>
<p>关于箭头函数，之所以这么称呼，是因为它就是由一个箭头来定义的，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">param</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> param*param;</div><div class="line">&#125;</div><div class="line"><span class="comment">//ES6 箭头函数</span></div><div class="line"><span class="keyword">var</span> foo= <span class="function"><span class="params">param</span> =&gt;</span> param*param;</div></pre></td></tr></table></figure>
<p>上面的代码简单比较了ES5中普通函数与ES6箭头函数的的写法，很明显的可以看出，箭头函数显得更加的简便，箭头函数中，有一些需要注意的地方：</p>
<p>返回值必须明确，并且在大括弧内必须加上return关键字，若是省略大括弧，则可以省略return</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回值的写法，下面两种是一样的</span></div><div class="line">() =&gt; <span class="string">"hello world"</span>;</div><div class="line"><span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">"hello word"</span>; &#125;</div></pre></td></tr></table></figure>
<p>当参数的数目不止一个或者没有的时候，需要用小括弧（）包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有参数或者多个参数需要加小括号 </span></div><div class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"hello world"</span>;</div><div class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">"hello word"</span>; &#125;</div><div class="line"><span class="keyword">var</span> foo2 = <span class="function">(<span class="params">param1,param2</span>) =&gt;</span> param1*param2;</div></pre></td></tr></table></figure>
<p>当返回的是一个对象的时候，需要注意大括弧外面加上（）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回对象需要函数体外面要加小括号</span></div><div class="line"><span class="keyword">var</span> foo3 = <span class="function"><span class="params">param</span> =&gt;</span> (&#123;<span class="attr">key</span>: value&#125;)</div></pre></td></tr></table></figure>
<p>箭头函数中this的使用跟普通函数也不一样，在JavaScript的普通函数中，都会有一个自己的this值，主要分为：</p>
<ol>
<li>函数作为全局函数被调用时，this指向全局对象</li>
<li>函数作为对象中的方法被调用时，this指向该对象</li>
<li>函数作为构造函数的时候，this指向构造函数new出来的新对象</li>
<li>还可以通过call，apply，bind改变this的指向</li>
</ol>
<p>在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5普通函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.age=<span class="number">22</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age+<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Man();</div><div class="line"><span class="built_in">console</span>.log(cala())<span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="comment">//ES6箭头函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.age=<span class="number">22</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.age+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cala=<span class="keyword">new</span> Man();</div><div class="line"><span class="built_in">console</span>.log(cala())<span class="comment">//23</span></div></pre></td></tr></table></figure>
<p>箭头函数中没有arguments(我们可以用rest参数替代),也没有原型，也不能使用new 关键字，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有arguments</span></div><div class="line"><span class="keyword">var</span> foo=<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>]*<span class="built_in">arguments</span>[<span class="number">1</span>]&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">3</span>,<span class="number">5</span>))</div><div class="line"><span class="comment">//arguments is not defined</span></div><div class="line"></div><div class="line"><span class="comment">//没有原型</span></div><div class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(Obj.prototype); </div><div class="line"><span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">//不能使用new 关键字</span></div><div class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="string">"hello world"</span>&#125;;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj(); </div><div class="line"><span class="comment">// TypeError: Obj is not a constructor</span></div></pre></td></tr></table></figure>
<p><strong>Rest参数</strong></p>
<p>Rest参数名为剩余参数，以…为前缀，上面讲过，ES6的箭头函数中不能使用arguments，我们可以用rest参数来替代，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo= <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> rest.length;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>在rest参数前面若是有其他的形式参数，那么rest参数只能放在最后面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">param1,param2,...rest</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> param1 + param2 + rest.length;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)) <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">param1,...rest,param2</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> param1 + param2 + rest.length;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)) <span class="comment">//  Rest parameter must be last formal parameter</span></div></pre></td></tr></table></figure>
<p><strong>默认参数值</strong></p>
<p>在ES6以前，函数调用时，那些没有传递的参数，JavaScript默认为undefined，ES6中新增了参数默认值，允许使用默认值来初始化形参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">param1,param2=<span class="number">10</span></span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> param1*param2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">10</span>)) <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>上面这个例子可以看到，定义了一个参数相乘的简单函数，在调用函数的时候，只传入了第一个参数的值，结果返回100，是因为在函数中第二个参数默认值为10，若我们在调用函数的时候没有显式的指明参数值，则会默认使用参数默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">param1,param2=<span class="number">10</span></span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> param1*param2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">10</span>，<span class="number">20</span>)) <span class="comment">// 200</span></div></pre></td></tr></table></figure>
<p>这次我们在调用函数大的时候，两个参数全部传递了值，因此返回200。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于ES6的学习总结，前两天写了第一篇，主要是关于变量声明关键字let和const，新增类型Symbol以及模板字符串，今天准备写第二篇，ES6里面的函数部分，ES6新增了箭头函数，Rest参数以及参数默认值。
    
    </summary>
    
      <category term="ECMAscript6" scheme="http://yoursite.com/categories/ECMAscript6/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6学习总结（一）</title>
    <link href="http://yoursite.com/2017/08/08/ES6-points-let/"/>
    <id>http://yoursite.com/2017/08/08/ES6-points-let/</id>
    <published>2017-08-07T16:38:06.000Z</published>
    <updated>2017-08-13T07:33:04.418Z</updated>
    
    <content type="html"><![CDATA[<p>前端发展的太快了，快到ES6,ES7出来之后，今年已经是ES8了，但是纵然前端发展很快，我们除了马不停蹄的学习新的技术之外，也要沉下心来，好好的潜心磨砺自己，本文是整理了自己学习ES6之后相关的知识要点，寄希望于书之于笔，一来自己可以更好地领悟，而来也可以留作日后翻阅查看。 <a id="more"></a></p>
<p>ES6新增的知识点主要包括变量声明let以及const,新增类型symbol，模板字符串，语法糖实现类，用于异步调用的promise对象，模块化，箭头函数，rest参数以及参数默认值，Set和Map集合，for of循环和迭代器iterator以及Generator等等，可以看出，ES6较之于ES5还是有着很多的新增特性，接下来会分为几篇文章将其一一介绍。</p>
<p><strong>let和const</strong></p>
<p>在JavaScript中咱们以前主要用关键var来定义变量，ES6之后，新增了定义变量的两个关键字，分别是let和const</p>
<p>对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//var声明变量</span></div><div class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// "true"</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="comment">//let声明变量</span></div><div class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// Uncaught ReferenceError: x is not defined</span></div><div class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出来，使用let我们可以伪造一个代码块，终于不再局限于函数作用域中，而且对于代码也会更加的规范，使用let定义变量，提倡人们先定义再使用，不然会报错。</p>
<p>const主要作用于定义常量，而且一旦声明，初始必须赋值，并且变量值不能更改，否则会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> CALA;</div><div class="line"><span class="comment">//Missing initializer in const declaration</span></div><div class="line"><span class="keyword">const</span> CALA=<span class="string">"calabash519"</span></div><div class="line">CALA=<span class="string">"hello world"</span>;</div><div class="line"><span class="comment">//Assignment to constant variable.</span></div></pre></td></tr></table></figure>
<p><strong>symbol</strong></p>
<p>ES6    以前，我们知道5种基本数据类型分别是Undefined，Null，Boolean，Number以及String，然后加上一种引用类型Object构成了JavaScript中所有的数据类型，但是ES6出来之后，新增了一种数据类型，名叫symbol，像它的名字表露的一样，意味着独一无二，意思是每个 Symbol类型都是独一无二的，不与其它 Symbol 重复。</p>
<p>可以通过调用 <code>Symbol()</code> 方法将创建一个新的 Symbol 类型的值，这个值独一无二，不与任何值相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol=<span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> mySymbol) <span class="comment">//"symbol"</span></div></pre></td></tr></table></figure>
<p>其他类型可以被强制转换成字符串，但是Symbol 却不能，千万不要这么做，不然会报错，提示TypeError。</p>
<p>可以使用Symbol来定义对象的属性，而且当Symbol作为属性名的时候，必须用[]来进行调用而不是点操作符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line">obj[mySymbol] = <span class="string">"calabash519"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj[mySymbol]); <span class="comment">//calabash519</span></div><div class="line"><span class="built_in">console</span>.log(obj.mySymbol); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>Symbol还可以使 instanceof 可扩展，在 ES6 中，<code>object instanceof constructor</code> 表达式被标准化为构造函数的一个方法：<code>constructor[Symbol.hasInstance](object)</code>，这意味着它是可扩展的。</p>
<p><strong>模板字符串</strong></p>
<p>字符串是JavaScript中基本类型之一，应该算是除了对象之外是使用最为频繁的类型吧，字符串中包含了例如substr，replace，indexOf,slice等等诸多方法，ES6引入了模板字符串的特性，用反引号来表示，可以表示多行字符串以及做到文本插值（利用模板占位符）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以前的多行字符串我们这么写：</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello world 1\n\</span></div><div class="line">hello cala");</div><div class="line"><span class="comment">// "hello world</span></div><div class="line"><span class="comment">// hello cala"</span></div><div class="line"></div><div class="line"><span class="comment">//有了模板字符串之后</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`hello world</span></div><div class="line">string text line 2`);</div><div class="line"><span class="comment">// "hello world</span></div><div class="line"><span class="comment">// hello cala"</span></div></pre></td></tr></table></figure>
<p>可以用${}来表示模板占位符，可以将你已经定义好的变量传进括弧中，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"cala"</span>;</div><div class="line"><span class="keyword">var</span> age=<span class="number">22</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`hello,I'am <span class="subst">$&#123;name&#125;</span>,my age is <span class="subst">$&#123;age&#125;</span>`</span>)</div><div class="line"><span class="comment">//hello,I'am cala,my age is 22</span></div></pre></td></tr></table></figure>
<p>上述是个很简单的例子，展示了模板字符串和模板占位符的基本用法，对比与普通字符串，模板字符串可以更好地支持自动转义特殊的字符串，也可以在其内嵌套控制语句，使得代码的逻辑更加清晰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端发展的太快了，快到ES6,ES7出来之后，今年已经是ES8了，但是纵然前端发展很快，我们除了马不停蹄的学习新的技术之外，也要沉下心来，好好的潜心磨砺自己，本文是整理了自己学习ES6之后相关的知识要点，寄希望于书之于笔，一来自己可以更好地领悟，而来也可以留作日后翻阅查看。
    
    </summary>
    
      <category term="ECMAscript6" scheme="http://yoursite.com/categories/ECMAscript6/"/>
    
    
  </entry>
  
  <entry>
    <title>设置对象的不可拓展</title>
    <link href="http://yoursite.com/2017/07/26/object-extension/"/>
    <id>http://yoursite.com/2017/07/26/object-extension/</id>
    <published>2017-07-26T15:04:43.000Z</published>
    <updated>2017-08-15T15:52:35.151Z</updated>
    
    <content type="html"><![CDATA[<p> 一般来说，默认情况下，对象都是可拓展的，我们可以为其属性进行增删改等操作，也可以更改他们原型的指向，如何让一个对象变得不可拓展呢，我们可以使用ES5提供的几个方法，来保证锁定的对象是不可拓展的<a id="more"></a></p>
<p><strong>Object.preventExtensions</strong></p>
<p>Object.preventExtensions可以锁定对象，设置对象的不可拓展，可以阻止为对象添加新的属性，非严格模式下会默默不起作用，但是严格模式下会报错，可以用Object.isExtensible判断对象是否可拓展</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"cala"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(person);</div><div class="line"></div><div class="line">person.name = <span class="string">"John"</span>; </div><div class="line">person.age = <span class="number">24</span>;</div><div class="line"><span class="comment">// 严格模式下会报错： TypeError: Cannot add property age, object is not extensible</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person) </div><div class="line"><span class="comment">// &#123;name: "John"&#125;</span></div></pre></td></tr></table></figure>
<p><strong>Object.seal</strong></p>
<p>Object.seal和上面的Object.preventExtensions方法作用是一样，字面意思是密封，也是用来防止对象被拓展，另外还可以阻止对象已有属性和方法的删除，可以用Object.isSealed判断对象是否可拓展</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"cala"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.seal(person);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(person)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(person)); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name </div><div class="line"><span class="comment">//  删除属性失败 严格模式下 Uncaught TypeError: Cannot delete property 'name' of #&lt;Object&gt;</span></div><div class="line"></div><div class="line">person.age = <span class="number">30</span>; <span class="comment">// </span></div><div class="line"><span class="comment">// 严格模式下会报错： TypeError: Cannot add property age, object is not extensible</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: "cala"&#125;</span></div></pre></td></tr></table></figure>
<p><strong>Object.freeze</strong></p>
<p>作用与上述两个方法大致相同，字面意思是冰冻，还可以阻止对象的属性和方法被修改，可以用Object.isFrozen判断对象是否可拓展</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"cala"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(person);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(person)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(person)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(person)); <span class="comment">// true</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xyz"</span>; </div><div class="line">person.age = <span class="number">30</span>;     </div><div class="line"><span class="keyword">delete</span> person.name  </div><div class="line"><span class="comment">//上述三个操作，非严格模式不起作用，严格模式会报错</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: "cala"&#125;</span></div></pre></td></tr></table></figure>
<p>总的来说，上述三个操作方法preventExtensions，seal，freeze可以设置对象的不可拓展性，并且每个方法都针对对象的不可拓展有着不同的限制，另外还有三个判断方法，isExtensible，isSealed，isFrozen来对对象进行操作，返回Boolean值，来判断对象是否可拓展</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 一般来说，默认情况下，对象都是可拓展的，我们可以为其属性进行增删改等操作，也可以更改他们原型的指向，如何让一个对象变得不可拓展呢，我们可以使用ES5提供的几个方法，来保证锁定的对象是不可拓展的
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中函数纪要（下）</title>
    <link href="http://yoursite.com/2017/07/20/function-notes/"/>
    <id>http://yoursite.com/2017/07/20/function-notes/</id>
    <published>2017-07-20T11:04:43.000Z</published>
    <updated>2017-08-11T13:20:16.456Z</updated>
    
    <content type="html"><![CDATA[<p>在函数内部有着一个名叫arguments的类数组对象，内部包含着传入函数的所有参数，在arguments对象中，有一个名叫callee的属性，其作用可见下面这个阶乘的栗子： <a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> num*factorial(num<span class="number">-1</span>);</div><div class="line">    <span class="comment">//这里也可以写成如下方式</span></div><div class="line">    <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>))<span class="comment">//120</span></div></pre></td></tr></table></figure>
<p>可以看到的是，arguments.callee这个属性作为一个指针指向了拥有arguments对象的函数，也可以认为是当前正在执行的函数，而且可以消除与函数名factorial的耦合，不过值得注意的是，在ES5的严格模式下，调用arguments.callee方法会报错。</p>
<p>函数内部还有一个对象，就是我们所熟悉的this对象，this对象引用的是函数执行的环境对象，简单来说，this总是指向函数的直接调用者，而非间接调用者，在对象中，如果有new关键字，this指向new出来的那个对象。</p>
<p>在函数对象中，有个属性名为caller，这个属性作为一个引用，保存着调用当前函数的其他函数的引用，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  bar();<span class="comment">//function ()&#123;bar();&#125;</span></div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(bar.caller)<span class="comment">//arguments.callee.caller</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到的是，匿名函数内部调用了bar函数，在bar函数内部，因为 bar.calller指向了调用bar的匿名函数，所以执行bar.caller就等于匿名函数的源代码，同callee一样的是，在ES5中访问caller属性会报错。</p>
<p>函数内部除了以上容易混淆的属性以外，还有些方法有时候也会让人比较困惑，例如call跟apply，show the code</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a+b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(add.call(<span class="keyword">this</span>,a,b))</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(add.apply(<span class="keyword">this</span>,[a,b]))</div><div class="line">&#125;</div><div class="line">foo(<span class="number">20</span>,<span class="number">20</span>)<span class="comment">//40</span></div><div class="line">bar(<span class="number">20</span>,<span class="number">20</span>)<span class="comment">//40</span></div></pre></td></tr></table></figure>
<p>可以看到的是，call和apply两个方法作用都是在特定的作用域上面调用函数，换句话说，就是改变函数体内this指向，在foo和bar函数中，我们利用call和apply将函数的this值绑定到add函数上，因此它们便可以对内部的参数执行add函数里面的加法操作。</p>
<p>call和apply方法大作用致相同，不同的方法接受的参数，call必须要明确所有要处理的参数，也就是说，参数必须要逐个列举，而apply方法可以选择数组作为参数，因此可以在具体的环境中，看看是选择call还是apply方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在函数内部有着一个名叫arguments的类数组对象，内部包含着传入函数的所有参数，在arguments对象中，有一个名叫callee的属性，其作用可见下面这个阶乘的栗子：
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中函数纪要（上）</title>
    <link href="http://yoursite.com/2017/07/18/function-property/"/>
    <id>http://yoursite.com/2017/07/18/function-property/</id>
    <published>2017-07-18T08:04:43.000Z</published>
    <updated>2017-08-11T13:20:46.963Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中函数是一等公民，所有的函数实际上是一个Function对象，与其他引用类型一样拥有着属性和方法，也可以被外界或者自身调用，也可以像传递参数一样将函数传递给另一个函数。 <a id="more"></a></p>
<p>JavaScript中函数没有重载的概念，当定义两个同名函数的时候，前一个函数会被覆盖掉，举个栗子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(num+<span class="number">100</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(num+<span class="number">200</span>)</div><div class="line">&#125;</div><div class="line">add(<span class="number">100</span>)<span class="comment">//300</span></div></pre></td></tr></table></figure>
<p>为何会没有函数重载，是因为JavaScript中函数定义有以下三种，分别是函数声明，函数表达式以及使用Function构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(num+<span class="number">100</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数表达式</span></div><div class="line"><span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(num+<span class="number">200</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Function构造函数</span></div><div class="line"><span class="keyword">var</span> add=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num"</span>,<span class="string">"console.log('num+300')"</span>)</div><div class="line"></div><div class="line">add(<span class="number">100</span>)<span class="comment">//400</span></div></pre></td></tr></table></figure>
<p>可以看到，当定义同名的函数的时候，也就相当于定义了同名的变量，故而后面的变量会覆盖掉前面的变量，另外需要注意的是JavaScript作用域中的 hoist，包括变量声明提升与函数函数提升。</p>
<p>对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//var声明变量</span></div><div class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// "true"</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="comment">//let声明变量</span></div><div class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// Uncaught ReferenceError: x is not defined</span></div><div class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>对于函数来说，函数声明会被提升到作用域顶部，而函数表达式则不会，因而比较稳妥的是在最后调用函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数声明</span></div><div class="line">hoist()<span class="comment">// hello world</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoist</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数表达式</span></div><div class="line">hoist()<span class="comment">// hoist is not a function</span></div><div class="line"><span class="keyword">var</span> hoist = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以将函数作为另一个函数的结果返回，若是返回函数中保存着对外部函数的引用，会发生很好玩的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> foo=<span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> bar=<span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> foo*bar;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> handle=closure();</div><div class="line"><span class="built_in">console</span>.log(handle());<span class="comment">//20</span></div></pre></td></tr></table></figure>
<p>可以看到的是，我们在closure函数内部定义了两个局部变量，然后返回带有局部变量操作结果的匿名函数，将closure函数执行后的结果（保存着foo，bar变量引用的匿名函数）赋给handle变量，此时执行handle函数可以看到，输出了closure函数内局部变量操作的结果，此时我们称这种现象为闭包，闭包其实是一个函数，在上述栗子中便是指代的closure函数内的匿名函数。不过值得注意的是，由于闭包会携带包含它的外部函数的整个作用域，故而会很占内存，因此要及时释放变量的引用，不要让其常驻内存，不然会导致内存占用过多，最后出现内存泄漏的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中函数是一等公民，所有的函数实际上是一个Function对象，与其他引用类型一样拥有着属性和方法，也可以被外界或者自身调用，也可以像传递参数一样将函数传递给另一个函数。
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>作为一名前端应该具备的</title>
    <link href="http://yoursite.com/2017/07/12/neccssary-front/"/>
    <id>http://yoursite.com/2017/07/12/neccssary-front/</id>
    <published>2017-07-12T12:18:22.000Z</published>
    <updated>2017-08-11T13:22:24.152Z</updated>
    
    <content type="html"><![CDATA[<p><strong>了解 JavaScript 这门语言</strong>，包括 闭包、IIFE、this、prototype 及一些底层实现（ES、VO、AO）、熟悉常用的设计模式与 JavaScript 范式（比如实现类与私有属性）。另外，新的 ES6 已经问世，包括 class, module, arrow function等等 <a id="more"></a></p>
<p><strong>了解前端常用的网络及后端知识</strong>，包括 Ajax、JSON、HTTP 请求、GET/POST 差异、RESTful、URL hash/query、webSocket、常用的跨域方式（JSONP/CORS、HTTP 强缓存/协商缓存，以及如何利用 CDN 、静态网站/动态网站区别、服务器端渲染/前端渲染区别等等 </p>
<p><strong>学习使用进阶的 CSS</strong>，包括熟悉 CSS 3，使用 Scss/Less 等编译到 CSS 的语言，使用 autoprefixer 等 PostCSS 工具，了解 CSS 在 Scope/Namespace 上的缺陷，你还可以学习 CSS Modules、CSS in JS 这些有趣的新玩意 </p>
<p><strong>了解前端的模块化规范</strong>，AMD和CMD的作用原理和规范以及CommonJS 与 ES6 Modules 你必须要了解</p>
<p><strong>熟悉 Git 与 Shell 的使用</strong>，基于 git 的版本管理、分支管理与团队协作，包括简单的 Linux/Unix 命令</p>
<p><strong>熟悉并且习惯使用 Node</strong>，包括了解 npm、使用 Grunt/Gulp/Browserify/Webpack 优化你的工作流、对代码进行打包、混淆、压缩、发布，使用 Express/Koa 配合 MongoDB/Redis 涉足到后端领域，或者尝试用 Node 做后端渲染优化首屏体验 </p>
<p><strong>了解各种 HTML 5 的新 API</strong>，包括 Canvas，webGL、File API、App Cache、localStorage、IndexedDB、Drag &amp; Drop、更高级的 DOM API、Fetch API 等等 </p>
<p><strong>学习 JavaScript 的单线程与异步编程方法</strong>，包括 setTimeout/setInterval，回调与回调地狱、事件与event loop、还有 Promise 甚至 Async/Await </p>
<p><strong>了解浏览器</strong>，包括主流浏览器的名称、内核与差异、包括私有属性与 -webkit- 等厂商前缀，需要学习如何使用 Chrome DevTool，需要了解浏览器渲染的 reflow/repaint 来避免 Jank 并进行有针对性的性能优化 </p>
<p><strong>学习 Mobile Web</strong>，因为移动互联网是趋势。包括 viewport、CSS pixel、 touch 事件、iOS/Android 浏览器的差异与兼容、移动端的性能优化、300ms delay 等等…需要知道 Hybrid 是什么，包括 Cordova/Phonegap，更复杂的比如和 iOS/Android 通信的机制，比如 URI Scheme 或者 JS Bridge </p>
<p><strong>学习一些非常火热的前端框架/库</strong>，理解其背后所蕴含的思想。包括 Backbone、Angular、Vue、React、Polymer 等等、了解它们背后的双向数据绑定、单向数据流、MVC/MVVM/Flux 思想、Web Component 与组件化等等 </p>
<p><strong>学习如何构建 web 单页应用</strong>，这是 web 的未来，包括利用 history API 或者 hash 实现路由，包括基于 Ajax + 模版引擎或者其他技术的前端渲染、包括组织较为复杂的软件设计等等 </p>
<p><strong>学习更多的计算机知识</strong>，包括简单的计算机体系结构、更广泛的编程知识（面向对象/函数式等）、栈、堆、数组、队列、哈希表、树、图等数据结构、时间复杂度与空间复杂度以及简单的算法等等 </p>
<p><strong>很强的自学能力、对技术有热情并且不断跟进</strong>。学习新的技术，比如 Universal JavaScript、Isomorphic JavaScript、前端测试、HTML5 页游、WebRTC、WebSocket、CSS 4、SVG、HTTP/2、ES 7、React Native、Babel、TypeScript、Electron 等等 </p>
<p><strong>内容来自：<a href="http://huangxuan.me/2015/10/28/how-designer-learn-fe/" target="_blank" rel="external">设计师如何学习前端</a> from 黄玄</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;了解 JavaScript 这门语言&lt;/strong&gt;，包括 闭包、IIFE、this、prototype 及一些底层实现（ES、VO、AO）、熟悉常用的设计模式与 JavaScript 范式（比如实现类与私有属性）。另外，新的 ES6 已经问世，包括 class, module, arrow function等等
    
    </summary>
    
      <category term="规划" scheme="http://yoursite.com/categories/%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown插入图片</title>
    <link href="http://yoursite.com/2017/07/07/upload-picture-using-github/"/>
    <id>http://yoursite.com/2017/07/07/upload-picture-using-github/</id>
    <published>2017-07-07T02:05:22.000Z</published>
    <updated>2017-08-11T13:23:19.722Z</updated>
    
    <content type="html"><![CDATA[<p>博客写的不多，所以Markdown的话用的也不是特别熟练，有几次碰到要插入本地图片，都比较尬，网上找一下方法，有的说可以把图片放在相邻文件夹，直接写绝对路径，也有的说使用图床，包括微博， 阿里云，七牛等等，个人觉得都太麻烦，发现有一种方法比较合适（适合用github pages做博客的童鞋），下面听我娓娓道来。 <a id="more"></a></p>
<p>首先在本地电脑找个安全的地方建立一个存放Markdown图片的文件夹，在github上面建一个仓库存放这些图片，如下图所示：</p>
<p><img src="http://calabash519.github.io/my-picture/store.png" alt="store"></p>
<p>其次在创建的图片仓库的设置中找到GitHub Pages，将Source中的none设置为master branch， 随即你便可以将在你的GitHub Pages存放和查看你仓库中的文件（github上项目运行演示也是如此）</p>
<p><img src="http://calabash519.github.io/my-picture/setting.png" alt="setting"></p>
<p><img src="http://calabash519.github.io/my-picture/branch.png" alt="branch"></p>
<p>接着在地址栏中输入上图中github pages中的项目地址，在后面加上你想要的图片的图片名，便可以在线展示</p>
<p><img src="http://calabash519.github.io/my-picture/dingwei.png" alt="dingwei"></p>
<p><img src="http://calabash519.github.io/my-picture/show.png" alt="show"></p>
<p>最后将输入栏的地址拷贝在剪贴板，在Markdown插入该图片（图片的后缀名一定要注意），最后看下效果，如若顺利，图片会顺利展示</p>
<p><img src="http://calabash519.github.io/my-picture/pride.jpg" alt="pride"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客写的不多，所以Markdown的话用的也不是特别熟练，有几次碰到要插入本地图片，都比较尬，网上找一下方法，有的说可以把图片放在相邻文件夹，直接写绝对路径，也有的说使用图床，包括微博， 阿里云，七牛等等，个人觉得都太麻烦，发现有一种方法比较合适（适合用github pages做博客的童鞋），下面听我娓娓道来。
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>短期计划</title>
    <link href="http://yoursite.com/2017/06/23/plan/"/>
    <id>http://yoursite.com/2017/06/23/plan/</id>
    <published>2017-06-23T12:18:22.000Z</published>
    <updated>2017-08-15T14:40:28.546Z</updated>
    
    <content type="html"><![CDATA[<p>以前甘愿废柴倒没什么，后来踌躇满志却仍然混吃等死，日复一日，每天都活在无尽的自责和忏悔之中，也难怪被人看不起，每天看似努力，却还是自我催眠，毫无效率，定个计划，也督促自己严格执行。 <a id="more"></a></p>
<ul>
<li>leetcode刷题</li>
<li>定期阅读外文技术文章</li>
<li>75kg/6块腹肌+坚持早起看书</li>
<li>通读犀牛书/红皮书+看懂jQuery源码</li>
<li>技术栈:JavaScript(vue/react)+node/php+mongoDB/MySQL</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前甘愿废柴倒没什么，后来踌躇满志却仍然混吃等死，日复一日，每天都活在无尽的自责和忏悔之中，也难怪被人看不起，每天看似努力，却还是自我催眠，毫无效率，定个计划，也督促自己严格执行。
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript排序算法</title>
    <link href="http://yoursite.com/2017/06/15/javascript-sort/"/>
    <id>http://yoursite.com/2017/06/15/javascript-sort/</id>
    <published>2017-06-15T01:55:36.000Z</published>
    <updated>2017-08-11T13:21:11.100Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中几种排序算法的实现<a id="more"></a></p>
<p>插入排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i,len=arr.length;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++) &#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; arr[i<span class="number">-1</span>]&gt;arr[i])&#123;</div><div class="line">      arr[i]=arr[i<span class="number">-1</span>];</div><div class="line">      i--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i,</div><div class="line">      j,</div><div class="line">      minIndex,</div><div class="line">      len=arr.length;			</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</div><div class="line">    minIndex=i;</div><div class="line">    <span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;len;j++) &#123;</div><div class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;</div><div class="line">        minIndex=j;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> temp=arr[i]</div><div class="line">    arr[i]=arr[minIndex]</div><div class="line">    arr[minIndex]=temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>冒泡排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i,</div><div class="line">      j,</div><div class="line">      len=arr.length;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++) &#123;</div><div class="line">      <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</div><div class="line">        <span class="keyword">var</span> temp=arr[j];</div><div class="line">        arr[j]=arr[j+<span class="number">1</span>];</div><div class="line">        arr[j+<span class="number">1</span>]=temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中几种排序算法的实现
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>四百里</title>
    <link href="http://yoursite.com/2017/06/05/lalala/"/>
    <id>http://yoursite.com/2017/06/05/lalala/</id>
    <published>2017-06-05T01:55:36.000Z</published>
    <updated>2017-07-15T18:08:48.833Z</updated>
    
    <content type="html"><![CDATA[<center><font>今日芒种</font></center><br><center><font>窗外风骤起</font></center><br><center><font>有人安然入梦</font></center><br><center><font>有人辗转，分秒皆凌迟</font></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font&gt;今日芒种&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;&lt;font&gt;窗外风骤起&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;&lt;font&gt;有人安然入梦&lt;/font&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;&lt;font&gt;有人辗转，分秒皆凌
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB可视化工具之RoboMongo</title>
    <link href="http://yoursite.com/2017/05/15/mongodb-and-robomango/"/>
    <id>http://yoursite.com/2017/05/15/mongodb-and-robomango/</id>
    <published>2017-05-15T01:55:36.000Z</published>
    <updated>2017-08-11T13:21:38.673Z</updated>
    
    <content type="html"><![CDATA[<p>每个前端的心里都少不了一个全栈的梦，最近在折腾node，所以少不了数据库的操作，由于以前对于数据库接触也比较少，所以开始学习MongoDB多少有点忐忑，不过开始了以后才发现，原来非关系型数据库大哥MongoDB也挺好学的啊，不过总是用MongoDB shell中总是觉得麻烦也不直观，所以想着找一个MongoDB的可视化工具用用，后来找到了RoboMongo，这名字听起来怪怪的，不过用起来才发现，真还挺好用。 <a id="more"></a></p>
<p>MongoDB是一个开源的NoSQL数据库，相比MySQL那样的关系型数据库，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储(文档，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，数据格式就是JSON。</p>
<p>想学MongoDB的话，基本的安装跟shell操作应该是不用多说，网上的文档教程太多，用点心总是能够弄好的。MongoDB的下载地址：<a href="https://www.mongodb.com" target="_blank" rel="external">摸我</a>，  RoboMongo的下载地址：<a href="https://robomongo.org" target="_blank" rel="external">摸我</a></p>
<p>下载安装好了以后通过管理员身份打开控制台，启动MongoDB</p>
<p><img src="https://calabash519.github.io/my-picture/shell.png" alt="shell"></p>
<p>然后打开RoboMongo，连接上MongoDB，下面就可以开始愉快的右键创建数据库，集合和文档：</p>
<p><img src="https://calabash519.github.io/my-picture/robo.png" alt="robo"></p>
<p>集合类似于关系型数据库中的表，而文档类似于关系型数据库中的行，集合是无模式的，所以也就意味着集合可以由各种各样的文档组成（心疼管理员一秒），其实将文档整理分开在特定的集合中可以更好地索引，但是MongoDB就是没有强制要求（傲娇），这也说明了MongoDB的灵活性不是吗？</p>
<p>通过命令行（卧槽，有可视化工具谁还用命令行，不过多用shell可以更熟练）或者是RoboMongo创建新的文档：</p>
<p>手动创建了一个叫做test的数据库和一个叫做myblog的集合，然后插入文档（个人还是比较喜欢在RoboMongo操作，感觉简直不要太好用啊），如下图所示：</p>
<p><img src="https://calabash519.github.io/my-picture/insert.png" alt="insert"></p>
<p>可以看到的是，其实其代码高亮也是比较漂亮的（虽然界面做的比较丑），然后就是你可以在上面的小栏那里进行增删改查，完了F5就可以看到你想要的结果，具体MongoDB操作请看下面链接：</p>
<p><a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/MongoDB%20%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8.md" target="_blank" rel="external">MongDB 极简实践入门</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/mongodb/" target="_blank" rel="external">MongDB教程</a></p>
<p><a href="https://book.douban.com/subject/6068947/" target="_blank" rel="external">MongDB权威指南1</a></p>
<p><a href="https://book.douban.com/subject/25798102/" target="_blank" rel="external">MongDB权威指南2</a></p>
<p>说到底你会用MongoDB shell的话就会用RoboMongo，个人觉得RoboMongo还更加的直观跟方便，MongDB以JSON的形式展示数据显然对于web开发者来说更加友好，配合node使用也是不错，最后，希望RoboMongo好好做下界面，求你们了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个前端的心里都少不了一个全栈的梦，最近在折腾node，所以少不了数据库的操作，由于以前对于数据库接触也比较少，所以开始学习MongoDB多少有点忐忑，不过开始了以后才发现，原来非关系型数据库大哥MongoDB也挺好学的啊，不过总是用MongoDB shell中总是觉得麻烦也不直观，所以想着找一个MongoDB的可视化工具用用，后来找到了RoboMongo，这名字听起来怪怪的，不过用起来才发现，真还挺好用。
    
    </summary>
    
      <category term="MongDB" scheme="http://yoursite.com/categories/MongDB/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript数组去重</title>
    <link href="http://yoursite.com/2017/04/25/unique-array/"/>
    <id>http://yoursite.com/2017/04/25/unique-array/</id>
    <published>2017-04-25T12:05:22.000Z</published>
    <updated>2017-08-11T13:23:05.548Z</updated>
    
    <content type="html"><![CDATA[<p>面试中对数组的考察，工作中对于数组的利用已经是家常便饭，而数组去重也是一个老生常谈的话题，接下来谈下我对于数组去重常用的三种思路。 <a id="more"></a></p>
<p>第一种：</p>
<ol>
<li>定义一个新的数组，准备存放已知数组的元素</li>
<li>判断元素是否存在于新的数组中，不存在则将元素添加到新的数组中</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> newArr=[],len=arr.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</div><div class="line">    <span class="keyword">if</span>(newArr.indexOf(arr[i])==<span class="number">-1</span>)&#123;</div><div class="line">      newArr.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newArr;</div><div class="line">&#125;			</div><div class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">'3'</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])) </div><div class="line"><span class="comment">//[1, 2, "3", 3, 4, 5, 6, 7]</span></div></pre></td></tr></table></figure>
<p>第二种：</p>
<ol>
<li>对已知数组进行排序，相同的元素会紧邻在一起</li>
<li>判断数组中前一个元素与后一个元素是否相同，并且判断前一个元素是否存在于新构建的数组中</li>
<li>前一步若是返回真，则将元素添加到新的数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteOdd2</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  arr.concat().sort();</div><div class="line">  <span class="keyword">var</span> len=arr.length;</div><div class="line">  <span class="keyword">var</span> newArr=[];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</div><div class="line">    <span class="keyword">if</span>(arr[i]!==arr[i+<span class="number">1</span>]&amp;&amp;newArr.indexOf(arr[i])==<span class="number">-1</span>)&#123;</div><div class="line">      newArr.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newArr;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(deleteOdd2([<span class="number">1</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'3'</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">65</span>,<span class="number">6</span>,<span class="number">6</span>]))</div><div class="line"><span class="comment">//[1, 22, 3, "3", 4, 5, 65, 6]</span></div></pre></td></tr></table></figure>
<p>第三种：利用ES6的map和set进行去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !seen.has(a) &amp;&amp; seen.set(a, <span class="number">1</span>));</div><div class="line"> &#125;</div><div class="line"> <span class="built_in">console</span>.log(unique([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">45</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]));</div><div class="line"> <span class="comment">//[1, 2, 3, 4, 45, 5]</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试中对数组的考察，工作中对于数组的利用已经是家常便饭，而数组去重也是一个老生常谈的话题，接下来谈下我对于数组去重常用的三种思路。
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>十月围城</title>
    <link href="http://yoursite.com/2017/04/23/my-first-blog/"/>
    <id>http://yoursite.com/2017/04/23/my-first-blog/</id>
    <published>2017-04-23T09:05:22.000Z</published>
    <updated>2017-08-11T13:22:01.463Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;去年七月到如今的四月，十个月，一切好似梦一场，一路的孤独，迷茫，绝望以及成长，感觉都历历在目，而最后自己还是亲手将自己送回原点，逼自己重新开始。<a id="more"></a><br>&emsp;&emsp;十个月感觉自己的经历好似太多，也给自己带来很大的改变。七八九月在咸宁留校学习通宵达旦，十月武汉的见习和奔赴千里于南京相聚离别，十一月的咸宁的意气全马和深圳的梧桐烟雨，十二月的花城懵懂实习，三月的福州出差昏天黑地。四月的坚决辞职返校陪她。一路走来，有过太多难忘，也有过太多的收获和失望。其实自己此时此刻更应该是在公司加班赶项目才对，而不是坐在寝室悠哉写博客。<br>&emsp;&emsp;就技术而言，自己更像是一个还没有学会走路的孩子，九月底接触前端，然后十二月在广州实习，将近四个月的实习，自己学到了很多，好似在我十一月去深圳的时候，我就做好了身份转换的准备，所以在那以后，我更多的感受是怎么努力学好技术提高自己。还记得刚到公司一直到年会放假，自己每天都待在公司，包括节假日和跨年，因为刚出来上班的缘故，所以很想快点提高自己。<br>&emsp;&emsp;其实这次辞职离开公司，是一个很突然的决定，连老板丹姐也说，对我寄予了很大的期望，不知道我为何会离开，其实对于公司，对于这份实习，我一直心怀感激其实有太多复杂的情感，  但是自己还是坚决的离开了团队，纵使心怀愧疚，但是仍然不后悔，虽然这个决定确实是错误的，自己也因此背负了很大的压力（毕竟三方也跟公司签过了），而且也会影响我以后的轨迹，但是正如自己所想：人生若无悔，那该多无趣呢？自己只是很固执的觉得要趁着大学毕业以前去做完那些我认为当下更重要的事情。<br>&emsp;&emsp;展望以后，只是希望自己这段时间学校待完，收拾好自己的一切，重新开始，正如十个月以前自己的初心，而自己现在相比十个月以前，也更加的坚定，知道自己应该做什么，应该怎么走。<br>&emsp;&emsp;最后送一句话给自己，也送给那些关心和帮助我的人： 悬崖亦是前程万里。 </p>
<p><img src="https://calabash519.github.io/my-picture/back.jpg" alt="back"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;去年七月到如今的四月，十个月，一切好似梦一场，一路的孤独，迷茫，绝望以及成长，感觉都历历在目，而最后自己还是亲手将自己送回原点，逼自己重新开始。
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Echarts初体验</title>
    <link href="http://yoursite.com/2017/03/14/Echarts-map/"/>
    <id>http://yoursite.com/2017/03/14/Echarts-map/</id>
    <published>2017-03-14T13:31:03.000Z</published>
    <updated>2017-08-11T13:19:34.541Z</updated>
    
    <content type="html"><![CDATA[<p>因为公司业务需求，前些阵子接触到了<a href="http://echarts.baidu.com/" target="_blank" rel="external">Echarts</a>，百度旗下开源的一个图标库，底层依赖 Canvas 类库 <a href="https://github.com/ecomfe/zrender" target="_blank" rel="external">ZRender</a>，其高度可个性化定制的数据可视化图表用来做数据分析，图形展示再合适不过，而且相对于D3陡峭的学习曲线，Echarts对于初学者更加友好，API随拿随用，在图表分析方面，不失为一个好的选择。 <a id="more"></a></p>
<p><img src="https://calabash519.github.io/my-picture/Echarts.png" alt="Echarts"></p>
<p>在Echarts官网，有完备的教程和对应的<a href="http://echarts.baidu.com/api.html#echarts" target="_blank" rel="external">API</a>，还有由各种图表组成的画廊，在那里你可以找到你想要的模板或者你也可以根据翻阅其API来拓展和自定义自己的需求。</p>
<p><img src="https://calabash519.github.io/my-picture/gallary.png" alt=" gallery"></p>
<p>我自己也根据官网的API和gallery的图表修改自制定实现了几个图表包括地图和折线图，饼图，柱状图等。</p>
<ul>
<li>病人指标折线图</li>
</ul>
<p><img src="https://calabash519.github.io/my-picture/line.png" alt="line"></p>
<ul>
<li>航班流向检测图</li>
</ul>
<p><img src="https://calabash519.github.io/my-picture/air.png" alt="air"></p>
<p>目前开源的可视化图表库有D3.js,highcharts,Echarts,不过最后一比较的话，个人还是觉得Echarts比较好，毕竟炫酷又容易上手，D3上手太花时间了，hightcharts的话太过简洁，动画效果也没有Echarts做的漂亮，最后，希望百度能够坚持把Echarts越做越好吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为公司业务需求，前些阵子接触到了&lt;a href=&quot;http://echarts.baidu.com/&quot;&gt;Echarts&lt;/a&gt;，百度旗下开源的一个图标库，底层依赖 Canvas 类库 &lt;a href=&quot;https://github.com/ecomfe/zrender&quot;&gt;ZRender&lt;/a&gt;，其高度可个性化定制的数据可视化图表用来做数据分析，图形展示再合适不过，而且相对于D3陡峭的学习曲线，Echarts对于初学者更加友好，API随拿随用，在图表分析方面，不失为一个好的选择。
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack的基本使用</title>
    <link href="http://yoursite.com/2017/02/11/webpack-exper/"/>
    <id>http://yoursite.com/2017/02/11/webpack-exper/</id>
    <published>2017-02-10T17:55:36.000Z</published>
    <updated>2017-08-11T13:23:42.266Z</updated>
    
    <content type="html"><![CDATA[<p>个人接触前端并不是很久，对于webpack却是久仰大名，也难怪， 作为一款优秀的模块加载器兼打包工具，webpack近来风头可谓一时无二，自己也想着学习并希望能够了解其工作方式和理念，抛开跟风不谈，至少学习新的技术对自己是大有裨益的。 <a id="more"></a></p>
<p><img src="https://calabash519.github.io/my-picture/webpack.png" alt="webpack"></p>
<p>引用一张webpack<a href="https://webpack.js.org/" target="_blank" rel="external">官网</a>的图片，作为一款模块打包器，webpack负责分析模块间的依赖关系，随即将模块按照不同的加载器规则生成相对应的资源。我们需要模块化工具为我们做的，包括初始加载量少，按需加载，自定义打包逻辑等功能功能，webpack都能够满足，它的loader加载器可以将各种类型的资源转换成我们所需要的模块，其丰富的插件系统也让我们自定义需求。</p>
<p><strong>安装</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//node 环境自不必多说</span></div><div class="line"><span class="comment">//全局安装webpack</span></div><div class="line">npm install -g webpack</div><div class="line"><span class="comment">//进入项目目录</span></div><div class="line"><span class="comment">//生成package.json</span></div><div class="line">npm init</div><div class="line"><span class="comment">//安装webpack依赖</span></div><div class="line">npm install webpack --save-dev</div></pre></td></tr></table></figure>
<p><strong>基本使用</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//静态页面：index.html</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JS文件入口：entry.js</span></div><div class="line"><span class="built_in">document</span>.write(<span class="string">"Hello world. "</span>)</div></pre></td></tr></table></figure>
<p>编译 entry.js 并打包到 bundle.js,于命令行输入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack entry.js bundle.js</div></pre></td></tr></table></figure>
<p>随即你会看到命令行会显示日志，提示你打包成功，打开浏览器运行index.html，你会看到Hello world.</p>
<p><strong>配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack=<span class="built_in">require</span>(<span class="string">"webpack"</span>);</div><div class="line"><span class="built_in">module</span>.exports=&#123;</div><div class="line">	<span class="comment">//页面入口设置</span></div><div class="line">	entry:<span class="string">"./entry.js"</span>,</div><div class="line">	<span class="comment">//入口文件输出配置</span></div><div class="line">	output:&#123;</div><div class="line">		<span class="attr">path</span>:__dirname,</div><div class="line">		<span class="attr">filename</span>:<span class="string">"bundle.js"</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">module</span>:&#123;</div><div class="line">		<span class="comment">//加载器配置</span></div><div class="line">		loaders:[</div><div class="line">          <span class="comment">//加载器可以使用简称例如style,其具体规则可见webpack的resolveLoader.moduleTemplates api</span></div><div class="line">          <span class="comment">//.css 文件使用style-loader和css-loader加载器来处理</span></div><div class="line">          &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">           <span class="comment">//图片文件使用url-loader加载器来处理，小于8kb的话则转换成base64</span></div><div class="line">		  &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//插件项配置</span></div><div class="line">	plugins:[</div><div class="line"> 		<span class="comment">//为bundle.js头部添加注释信息     </span></div><div class="line">		<span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"this file is created by cala"</span>)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>webpack.config.js配置基本上存在于每一个使用webpack项目中，作为一个配置项，告诉webpack它的具体功能，包括加载器作用与插件项的功能，所有的加载器都是通过npm来加载，可以阅读相应的文档来了解不同加载器所提供的功能。</p>
<p><strong>执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --watch</div></pre></td></tr></table></figure>
<p>启动监听模式，如此便可以避免在每次修改模块后都重新编译，开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack-dev-server -g</div></pre></td></tr></table></figure>
<p>使用webpack-dev-server构建本地服务器，在浏览器输入localhost：8080会以监听模式自动运行webpack</p>
<p>关于webpack其实还有很多令人惊奇的地方，看官方文档可以知道很多关于webpack的工作原理或者是其相关的周边生态，道阻且长，也希望自己能够不断的学习新的技术，未来能够用于项目中，更深的体会其原理跟奥妙。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人接触前端并不是很久，对于webpack却是久仰大名，也难怪， 作为一款优秀的模块加载器兼打包工具，webpack近来风头可谓一时无二，自己也想着学习并希望能够了解其工作方式和理念，抛开跟风不谈，至少学习新的技术对自己是大有裨益的。
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
  </entry>
  
</feed>
